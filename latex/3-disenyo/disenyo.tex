\documentclass{article}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{physics}

\title{Diseño}

\begin{document}

\maketitle{}

\section{Problemas de optimización combinatoria}

Un problema de optimización combinatoria se define con la siguiente función de coste:
\begin{align*}
  f(z) = \sum_{\alpha = 1}^{m} f_\alpha(z) \\
  \textnormal{ dde } z = z_1z_2...z_n \textnormal{ y } z_i\in{\{0, 1\}} \\
   f_{\alpha}(z) = \begin{cases}
     1 \textnormal{ si z satisface } f_\alpha \\
     0 \textnormal{ en otro caso}
   \end{cases}
\end{align*}

En este caso el objetivo será encontrar el \textbf{mínimo global} de esta función. Para esto mismo se debe encontrar una cadena de bits de tamaño \textit{n} que cumplan para la mayor cantidad de cláusulas $f_\alpha(z) = 0$.

Para que sean aplicados a algoritmos cuánticos estos problemas no pueden tener restricciones añadidas, por lo que el espacio de resultados posibles será de $2^n$ combinaciones.

\subsection{Añadir restricciones}

Si el problema que se está intentando representar tiene restricciones de la forma $A(z) = B(z)$ la forma de añadirlas a la función de coste sería $f'(z) = f(z) + P*(A(z)-B(z))^2$, donde
\begin{align*}
  P*(A(z) - B(z))^2 \begin{cases}
    = 0 \textnormal{ si se cumple la restricción } \\
    \ge P \textnormal{ en otro caso }
  \end{cases}
\end{align*}

El parámetro P se denomina \textit{modificador de Lagrange} y tiene un valor lo suficientemente grande como para que el castigo en caso de romper una restricción aumente lo suficiente el valor de la función de coste como para que sea mayor que cualquier otro resultado en el que no se rompa. Esto sería: $P > max_zf(z)$

\section{Formulación de QAOA}
El sistema cuántico en el algoritmo se desarrolla sobre un espacio de Hilbert de $2^n$ dimensiones, donde \textit{n} es el número de bits de entrada en la función de coste clásica. Esto quiere decir que se tendrán tantos qubits como bits tenga la entrada de \textit{f(z)}.

La base computacional se representa como $\{\ket{z} : z \in \{0, 1\}^n\}$.

La idea general de QAOA se basa en preparar un estado \(\lvert \psi(\vec{\beta}, \vec{\gamma})\rangle\) tal que, con los valores adecuados \( (\vec{\beta_{opt}}, \vec{\gamma_{opt}}) \), el estado \(\lvert\psi(\vec{\beta_{opt}}, \vec{\gamma_{opt}})\rangle\) encuentre la solución al problema. Los parámetros de dicho estado son:
\begin{align*}
  \vec{\beta} = [\beta_0, \beta_1, ..., \beta_{p-1}] \\
  \vec{\gamma} = [\gamma_0, \gamma_1, ..., \gamma_{p-1}] \\
\end{align*}
Donde \textit{p} es el número de capas del circuito y $\beta_i, \gamma_i \in{[0, 2\pi]}$.

Este estado consta de tres componentes: el \textbf{estado inicial} ($\ket{\psi_0}$); y dos operadores denominados \textbf{problem hamiltonian} ($U(C, \gamma)$) y \textbf{mixing hamiltonian} ($U(B, \beta)$).
Estos se combinan de la siguiente forma:
\[
  \lvert\psi(\vec{\beta}, \vec{\gamma})\rangle = U(B, \beta_{p-1})U(C, \gamma_{p-1})U(B, \beta_{p-2})U(C, \gamma_{p-2}) ... U(B, \beta_0)U(C, \gamma_0) \ket{\psi_0}
\]

\subsection{Estado inicial}
El estado inicial del qubit se define como
\begin{align*}
  \ket{\psi_0} = \frac{1}{\sqrt{2^n}} \sum_z\ket{z}
  = (\frac{1}{\sqrt{2}} (\ket{0} + \ket{1}))^{\otimes n}
  = H^{\otimes n} \ket{0}^{\otimes n}
\end{align*}

Este estado inicial se construye añadiendo operadores de Hadamard a \textit{n} qubits inicializados a $\ket{0}$, lo que genera un estado equiprobable, es decir, donde la probabilidad de obtener una cadena dada de \textit{n} bits al medir el estado sería en cualquier caso $\frac{1}{2^n}$.

\subsection{Problem hamiltonian y mixing hamiltonian}

Los operadores se definen como:
\begin{align*}
  U(B, \beta_i) = e^{-i \beta_i B} \\
  U(C, \gamma_i) = e^{-i \gamma_i C} \\
\end{align*}

La operación \(U(X) = e^{-i X}\) sirve para garantizar la unitariedad del operador ya que, como se verá en su definición, \textit{B} y \textit{C} no son necesariamente unitarios
\footnote{En computación cuántica los operadores lineales deben ser unitarios. Tiene relación con la idea
  $\sum_{\ket{z}} {P(\ket{z})} = 1$,
  donde $\ket{z}$ itera sobre los vectores de la base computacional del sistema y
  \(P(\ket{z})\) se refiere a la probabilidad de medir i sobre dicha base.}.

Tanto la noción de hamiltoniano como la construcción de un operador unitario proceden de la ecuación de Schrödinger de la mecánica cuántica.
% TODO: Hablar en el apéndice sobre el segundo postulado del libro y su resolución. Añadir el QC-textbook como bibliografía.

\subsubsection{Operador \textit{B}}
\textit{B} se construye a partir de puertas Pauli-X ($\sigma^x$) y se define de la siguiente forma:
\begin{align*}
  &B = \sum_{i=0}^{n-1}\sigma^x_{i} &&\\
  &U(B, \beta) = e^{-i \beta B} = \prod_{j=0}^{n-1}e^{-i \beta \sigma^x_j} = \prod_{j=0}^{n-1}Rx_i(2*\beta)  % TODO: Citar aquí y definir Rx en el apéndice o a pie de página
\end{align*}

Como se puede ver únicamente depende de la cantidad de qubits del sistema.

\subsubsection{Operador \textit{C}}
\textit{C} se define a partir de la función de coste clásica del problema a resolver \textit{f(z)} y se construye utilizando puertas Pauli-Z ($\sigma^z$).

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
